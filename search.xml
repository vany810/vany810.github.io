<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MacOS系统装机环境配置命令大全]]></title>
    <url>%2F2017%2F12%2F20%2FMacOS%E7%B3%BB%E7%BB%9F%E8%A3%85%E6%9C%BA%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[系统设置macOS10.12+允许任何来源应用1sudo spctl --master-disable Finder显示隐藏文件1defaults write com.apple.finder AppleShowAllFiles -bool true Homebrew安装与配置安装Homebrew1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 替换国内镜像源 更换Homebrew的formula索引镜像（即brew update时所更新的内容） 123456789# 替换现有上游cd "$(brew --repo)"git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.gitcd "$(brew --repo)/Library/Taps/homebrew/homebrew-core"git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.gitbrew update 123456789#使用homebrew-science或者homebrew-pythoncd "$(brew --repo)/Library/Taps/homebrew/homebrew-science"git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-science.gitcd "$(brew --repo)/Library/Taps/homebrew/homebrew-python"git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-python.gitbrew update 更换Homebrew二进制预编译包的镜像 12echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles' &gt;&gt; ~/.bash_profilesource ~/.bash_profile Homebrew安装Java开发环境123456789101112131415# 查询javabrew cask search java# 查看版本信息brew cask info java# 安装最新版本javabrew cask install java# 需要安装其他版本brew tap caskroom/versionsbrew cask install java8# 查看当前安装的java版本java -version Ruby Gems镜像替换12345# 添加 TUNA 源并移除默认源gem sources --add https://mirrors.tuna.tsinghua.edu.cn/rubygems/ --remove https://rubygems.org/# 列出已有源gem sources -l# 应该只有 TUNA 一个 CocoaPods镜像替换123cd ~/.cocoapods/repos pod repo remove mastergit clone https://mirrors.tuna.tsinghua.edu.cn/git/CocoaPods/Specs.git master 最后进入自己的工程，在自己工程的Podfile第一行加上： 1source &apos;https://mirrors.tuna.tsinghua.edu.cn/git/CocoaPods/Specs.git&apos; pypi镜像替换修改 ~/.config/pip/pip.conf (Linux), %APPDATA%\pip\pip.ini (Windows 10) 或 $HOME/Library/Application Support/pip/pip.conf (macOS) (没有就创建一个)， 修改 index-url至tuna，例如 12[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple pip 和 pip3 并存时，只需修改 ~/.pip/pip.conf。]]></content>
      <categories>
        <category>Softwares</category>
      </categories>
      <tags>
        <tag>Mac系统</tag>
        <tag>命令行</tag>
        <tag>镜像源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Nginx+uwsgi进行Django部署]]></title>
    <url>%2F2017%2F12%2F20%2F%E4%BD%BF%E7%94%A8Nginx-uwsgi%E8%BF%9B%E8%A1%8CDjango%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[Python环境：3.6.xLinux系统：CentOS 7 安装nginx和需要的包12sudo yum install epel-releasesudo yum install python-devel nginx 安装uwsgi在项目虚拟环境或者全局使用pip安装： 12# 安装正式环境部署工具pip install uwsgi 配置文件在项目根目录创建conf文件夹，分别创建uc_nginx.conf和uwsgi.ini文件： uc_nginx.conf 1234567891011121314151617181920212223242526272829303132# the upstream component nginx needs to connect toupstream django &#123; # server unix:///path/to/your/mysite/mysite.sock; # for a file socket server 127.0.0.1:8000; # for a web port socket (we&apos;ll use this first)&#125;# configuration of the serverserver &#123; # the port your site will be served on listen 80; # the domain name it will serve for server_name 106.14.158.68; # substitute your machine&apos;s IP address or FQDN charset utf-8; # max upload size client_max_body_size 75M; # adjust to taste # Django media location /media &#123; alias /opt/softwares/dt_project/media; # 指向django的media目录 &#125; location /static &#123; alias /opt/softwares/dt_project/static; # 指向django的static目录 &#125; # Finally, send all non-media requests to the Django server. location / &#123; uwsgi_pass django; include uwsgi_params; # the uwsgi_params file you installed &#125;&#125; uwsgi.ini 12345678910111213141516171819202122[uwsgi]# Django-related settings# the base directory (full path)chdir = /opt/softwares/dt_project# Django's wsgi filemodule = drug_traceability.wsgi# the virtualenv (full path)virtualenv = /opt/softwares/envs/drug_traceability/# process-related settings# mastermaster = true# maximum number of worker processesprocesses = 5# the socket (use the full path to be safesocket = :8000buffer-size = 65535# ... with appropriate permissions - may be needed# chmod-socket = 664# clear environment on exitvacuum = true 加载自定义nginx配置文件复制自定义的nginx配置文件到该目录： 1cp project_dir/conf/uc_nginx.conf /etc/nginx/conf.d/ 然后重启nginx服务 uwsgi运行项目1uwsgi -i conf/uwsgi.ini]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python进阶 -- 集合使用]]></title>
    <url>%2F2017%2F07%2F31%2FPython%E8%BF%9B%E9%98%B6%20--%20%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Python环境：3.6.x 列表、字典、集合过滤在开发过程中经常会遇到这样的情况，得到一个结果集合，但是我们只需要集合中一部分满足特定条件的子集，通常我们有两种解决方案： filter函数 列表解析，字典解析，集合解析 123456789101112131415161718from random import randintdata = [randint(-10, 10) for _ in range(10)]print(data)# filter函数过滤filter_data = [item for item in filter(lambda x: x &gt;= 0, data)]print(filter_data)# 列表解析filter_list = [item for item in data if item &gt;= 0]print(filter_list)# 字典过滤dict = &#123;x: randint(60, 100) for x in range(1, 21)&#125;print(dict)filter_dict = &#123;k: v for k, v in dict.items() if v &gt;= 90&#125;print(filter_dict)# 集合过滤s = set(data)filter_set = &#123;x for x in s if x % 3 == 0&#125;print(filter_set) 改进元组的可读性我们在使用元组的时候，通常会像以下方式，通过索引去获取元组中的值，日常开发过程，如果不注重代码可读性改善，那么你的代码中会到处都是1，2，3…这些索引，然而很多时候不能直观地知道这些索引取出的值代表了什么。 1234t = ('Jam', 18, 'Shanghai', 'jam@gmail.com')name = t[0]age = t[1]local = t[2] 所以我们需要改进代码可读性，大部分初级开发者都会用这样的方式，通过定义一些常量来替换原有的数字索引： 1234# 元组的可读性命名NAME, AGE, ADDRESS, EMAIL = range(4)person_info = ('James', 18, 'New York', 'james@gmail.com')print(person_info[NAME], person_info[ADDRESS]) 接下来，我们来使用一种更为优雅的方式： 12345from collections import namedtuple# 使用标准库中的collections.namedtuple替代内置tuplePerson = namedtuple('Person', ['name', 'age', 'address', 'email'])p = Person('Tom', 20, 'London', 'tom@icloud.com')print(p.name, p.address, p.age) 统计序列中元素频率这种问题常见的例子有词频统计，那么如何实现呢？最简单粗暴的方式，也是我们最容易想到的可能是以下方式： 123456789101112from random import randint# 生成30个0到20的整数，则必然会有重复的数字data = [randint(0, 20) for _ in range(30)]print(data)# [16, 18, 6, 4, 15, 12, 4, 5, 17, 20, 15, 9, 3, 14, 7, 17, 15, 1, 14, 4, 6, 11, 7, 19, 10, 4, 8, 3, 9, 19]# 将data中的元素作为键，出现频率默认值为0创建一个结果字典result = dict.fromkeys(data, 0)# 循环遍历data，进行频率统计for x in data: result[x] += 1print(result)# &#123;16: 1, 18: 1, 6: 2, 4: 4, 15: 3, 12: 1, 5: 1, 17: 2, 20: 1, 9: 2, 3: 2, 14: 2, 7: 2, 1: 1, 11: 1, 19: 2, 10: 1, 8: 1&#125; 这么简单，没什么好讲的…那么如果我们要找到频率最高的5个数字要怎么办呢？当然，我们要先根据值进行排序再取出前五个元素，是不是比较麻烦呢？我们就来看更好的方式： 123456from collections import Counterresult = Counter(data)# most_common方法返回出现频率最多的结果most = result.most_common(5)print(most)# [(5, 3), (14, 3), (16, 3), (8, 3), (2, 2)] 字典排序根据字典中值得大小进行排序： 1234567from random import randintscores = &#123;x: randint(60, 100) for x in 'abcxyz'&#125;print(scores)# &#123;'a': 75, 'b': 95, 'c': 85, 'x': 96, 'y': 95, 'z': 61&#125;result = sorted(scores.items(), key=lambda x: x[1])print(dict(result))# &#123;'z': 61, 'a': 75, 'c': 85, 'b': 95, 'y': 95, 'x': 96&#125; 寻找字典公共键场景：有abcdefg七名球员，记录4轮比赛球员进球数量，然后寻找每轮都进球的球员 12345678from random import randint, samplefrom functools import reducedata = [&#123;k: randint(1, 4) for k in sample('abcdefg', randint(3, 6))&#125; for x in range(4)]print(data)# [&#123;'b': 2, 'g': 2, 'c': 2&#125;, &#123;'c': 4, 'g': 1, 'e': 2, 'd': 3, 'b': 3, 'a': 2&#125;, &#123;'b': 1, 'g': 1, 'c': 2&#125;, &#123;'c': 1, 'e': 1, 'd': 4, 'g': 1, 'f': 2&#125;]result = reduce(lambda a, b: a &amp; b, map(dict.keys, data))print(result)# &#123;'c', 'g'&#125;]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[引用类型和值类型]]></title>
    <url>%2F2017%2F06%2F05%2F%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%80%BC%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[引用类型和值类型的区别对任何一个严谨的Swift开发者来说，了解并利用引用类型和值类型的区别都是必须要掌握的技能，是的，是必须！！！（重要的事情三个感叹号，没毛病…） 其实，很多初学者并不是太清楚它们的区别，在选择或者使用的时候，往往做出错误的决定。我写一个简单示例： 1234567891011// 创建一个旅游目的地var target = Target()// 设置位置为海南三亚target.location = "海南三亚"// 小明要去三亚旅游xiaoMing.target = target// 小明的朋友小王看完天气预报，决定去杭州游玩target.location = "杭州"xiaoWang.target = targetprint(xiaoMing.target.location)print(xiaoWang.target.location) 如果Target是一个类，那么这在Swift中是引用类型，如果是一个结构体，那就是值类型，这我想大家都是知道的。 仅仅只是一个声明关键词的区别，但是结果却是完全不同的，如果Target是一个类，那么小明和小王的目的地都会变成杭州，这显然是不对的。如果是一个结构体，那么小明会去三亚，小王会去杭州，这是正确的。 对引用的概念比较清晰的开发者都应该知道出现这样情况的原因，因为在多个对象引用同一个示例时，其中一个进行操作都会影响其他，而值类型永远只会有一个所有者。 Swift大部分数据类型都是值类型。比如布尔值，整数，字符串，元组和枚举，即使是数组和字典也是值类型。像下面的代码将打印3而不是4： 1234var a = [1, 2, 3]var b = aa.append(4)print(b.count) 闭包是引用类型这个有点难以理解，如果你平时很少复制闭包，那么你可以忽略这块内容。 下面举一个实际的例子，下面的代码是一个createIncrementer()函数，它不接受参数并且返回一个闭包： 1234567func createIncrementer() -&gt; () -&gt; Void &#123; var counter = 0 return &#123; counter += 1 print(counter) &#125;&#125; createIncrementer()函数内部只有一个变量，counter被初始化为0，因为该变量要被返回的闭包中使用，所以闭包会捕获变量。所以，我们加几行代码在这个函数后面： 123let incrementer = createIncrementer()incrementer()incrementer() 调用两次，输出结果是1和2，和我们预期的是一致的。因为闭包是引用类型，如果我们创建另一个引用incrementer，它们将共享相同的闭包，因此也将共享相同的counter变量。例如： 123456let incrementer = createIncrementer()incrementer()incrementer()let incrementerCopy = incrementerincrementerCopy()incrementer() 这时候你会看到输出是1，2，3，4，到这里你应该明白了，闭包确实是引用类型。 为什么要使用结构体？我们最常面临的是类或者结构体之间的选择，往往多数情况下，我们要优先考虑使用结构体。 你已经知道，值类型是进行复制而不是共享，这意味着如果你的代码有三个不同的东西指向同一个结构体，那么它们每个都有自己的副本，不会互相干扰。 如果你开发的应用是比较复杂的，值类型最大的好处是它们本质上是线程安全的。也就是说，你在一个或者多个后台线程上进行工作，用值类型不可能引发竞态条件(race conditions)。 第一，竞态条件：这是两个并行运行的代码经常会引起的问题，其中完成的顺序影响程序的状态。例如，假设我正在开车去你家给你1000元，你的朋友也开车到你家要求你还他200元。我先到你家给你钱，你的朋友几分钟后到，你还给他200元，这样子没什么问题。如果你的朋友开车比我快，先到了你家，这种情况他要你还钱，但是你还没有从我这拿到1000元，这样问题就出现了。 在应用中，这就意味着在获取到结果前在尝试对结果进行操作，或者使用一些尚未创建的对象。毫无疑问，你的应用肯定会崩溃。 第二，线程安全：这是一个术语，意思是你的代码以多个线程使用你的数据结构而不相互影响。如果线程A修改了线程B正在使用的东西，那就不是线程安全的。 值类型本来就是线程安全的，因为它们不在线程之间共享，每个线程都会获得自己的数据副本进行处理，并且可以在不影响其他线程的情况下操作该副本。每个副本都与其他副本无关，所以也不会出现竞态条件。 避免线程问题是很好的，不过值类型有一个更大的好处：它们大大减少了代码中存在的关系数量。举个例子，通常Core Data应用程序在应用程序代理中设置数据库，然后在视图控制器之间传递数据库或者单个对象的引用。每次在视图控制器之间传递对象时，双向连接它们 —— 子视图控制器可以通过多种方式修改该对象，并且所有这些更改都将默认显示在父视图控制器中。这样就会导致你程序里的对象关系非常混乱。 选择结构体而不是类的最后一个原因：编译器会根据属性自动生成一个初始化方法。例如： 123456struct Person &#123; var name: String var age: Int var favoriteIceCream: String&#125;let taylor = Person(name: "Taylor Swift", age: 26, favoriteIceCream: "Chocolate") 为什么要使用类？类是引用类型，你可以创建一个资源，如数据库连接，并在应用程序中的大量对象之间共享，而无需创建新的连接。而且熟悉Objective-C的开发人员都习惯性地会去使用类。 使用类可能运行得非常快，因为你不需要在每次通过别的地方创建对象的副本。相反，你创建一个对象一次，并将其传递到需要的地方，只要你的代码是线程安全，对象甚至可以跨线程使用，并且不用担心太多。 另外类是可以继承的，这是面向对象编程最常用到的，父类实现一些通用功能，子类定制一些各自特有的功能。 最后，使用类的一个主要原因是，Cocoa Touch本身许多框架都是用类写的：UIKit，SpriteKit，MapKit，Core Location等等。]]></content>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PyCharm调试Hue教程]]></title>
    <url>%2F2017%2F06%2F01%2FPyCharm%E8%B0%83%E8%AF%95Hue%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[首先先吐槽一下，Hue这玩意如果你没做好心理准备，还是先不要入坑，本人是没有办法，公司要基于Hue进行二次开发，所以刚入手的时候每天各种填坑… 言归正传，Hue主要是基于Django框架写的，然而用到的Django版本老的让人觉得匪夷所思，这边我用到的是Hue3.11版本，最新的是3.12版本。 那么本地搭建好Hue项目后要进行Debug，需要进行以下步骤： 1.配置PyCharm虚拟环境目录进入PyCharm设置界面，进入如下图所示配置界面添加本地虚拟环境目录，加载出该环境依赖库则表示操作成功。 2.添加Django支持根据下图进入Django配置界面，然后配置右侧信息，对应自己项目目录下的文件目录。 3.添加Debug配置首先，打开Debug配置界面。 点击左上角+号添加Django server的配置，添加一个自定义设置名称，完成后点OK按钮。 如下图选中Debug目标，然后就可以进行Debug了。 当出现下图的打印日志信息中的Starting Development ... http://127.0.0.1:8000/，则表示Debug项目运行成功，这时候你就可以用自己的浏览器打开对应网址进行调试了。]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Hue</tag>
        <tag>PyCharm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django快速实现登录功能]]></title>
    <url>%2F2017%2F05%2F25%2FDjango%E5%BF%AB%E9%80%9F%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[如果用过Django的admin后台功能，你就会知道Django自带了登录登出等功能，那么我们要怎么利用这些现有的方法快速地实现我们自己的登录登出功能呢？ 因为我遇到这个需求是因为要做一个后台管理系统的Demo，如果花费大量的时间去写这些现成的逻辑肯定是不合理的。 其实很简单，这是我在urls.py文件中的代码： 123456789101112131415from django.conf.urls import url, includefrom django.contrib.auth import viewsfrom django.contrib import admin# 登录方法的参数设置params = &#123;'template_name': 'login.html', 'extra_context': &#123;'next': '/'&#125;&#125;# 退出登录成功后跳转到登录界面的设置login_url = &#123;'login_url': '/login/?next=/'&#125;urlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^login/$', views.login, params, name='login'), url(r'^logout/$', views.logout_then_login, login_url, name='logout'), ...] 这样我们就完成了url的配置。 这里还有一个问题，登录的html文件在哪里，其实很简单，只需要找到Django admin中login的html文件，然后自己新建一个需要使用的login.html文件，将其中的内容复制过来就OK了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html&gt;&lt;html&gt;&#123;% load staticfiles %&#125;&#123;% load rest_framework %&#125;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"&gt; &lt;meta name="description" content=""&gt; &lt;title&gt;&#123;% block title %&#125;孚典数据分析&#123;% endblock %&#125;&lt;/title&gt; &lt;!-- public stylesheet--&gt; &lt;link rel="stylesheet" href="&#123;% static 'stylesheets/bootstrap.min.css' %&#125;"&gt; &lt;link rel="stylesheet" href="&#123;% static 'stylesheets/font.css' %&#125;"&gt; &lt;link rel="stylesheet" href="&#123;% static 'stylesheets/style.css' %&#125;"&gt; &#123;% block stylesheet %&#125; &#123;% endblock %&#125; &lt;!-- public javascript--&gt; &lt;script type="text/javascript" src="&#123;% static 'javascripts/plugin/jquery/jquery-1.9.0.min.js' %&#125;"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="&#123;% static 'javascripts/plugin/bootstrap/js/bootstrap.min.js' %&#125;"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="&#123;% static 'javascripts/plugin/layer/layer.js' %&#125;"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="&#123;% static 'javascripts/common.js' %&#125;"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body style="background:url('&#123;% static 'images/bg.jpeg' %&#125;') no-repeat;background-size: 100%" &gt;&lt;div class="container"&gt;&lt;div class="login-box"&gt; &lt;h3 class="h3"&gt;AI大数据教育分析平台&lt;/h3&gt; &lt;form action="&#123;% url 'login' %&#125;" role="form" method="post" class="form-horizontal"&gt; &#123;% csrf_token %&#125; &lt;input type="hidden" name="next" value="&#123;&#123; next &#125;&#125;"/&gt; &lt;div id="div_id_username" class="form-box clearfix control-group &#123;% if form.username.errors %&#125;error&#123;% endif %&#125;"&gt; &lt;div class="form-group"&gt; &lt;label for="id_username" class="col-sm-3 control-label"&gt;用户名:&lt;/label&gt; &lt;div class="col-sm-9"&gt; &lt;input type="text" name="username" maxlength="100" autocapitalize="off" autocorrect="off" class="form-control textinput textInput" id="id_username" required autofocus &#123;% if form.username.value %&#125;value="&#123;&#123; form.username.value &#125;&#125;"&#123;% endif %&#125;&gt; &lt;/div&gt; &#123;% if form.username.errors %&#125; &lt;p class="text-error"&gt; &#123;&#123; form.username.errors|striptags &#125;&#125; &lt;/p&gt; &#123;% endif %&#125; &lt;/div&gt; &lt;/div&gt; &lt;div id="div_id_password" class="form-box clearfix control-group &#123;% if form.password.errors %&#125;error&#123;% endif %&#125;"&gt; &lt;div class="form-group"&gt; &lt;label for="id_password" class="col-sm-3 control-label"&gt;密码:&lt;/label&gt; &lt;div class="col-sm-9"&gt; &lt;input type="password" name="password" maxlength="100" autocapitalize="off" autocorrect="off" class="form-control textinput textInput" id="id_password" required&gt; &lt;/div&gt; &#123;% if form.password.errors %&#125; &lt;p class="text-error"&gt; &#123;&#123; form.password.errors|striptags &#125;&#125; &lt;/p&gt; &#123;% endif %&#125; &lt;/div&gt; &lt;/div&gt; &#123;% if form.non_field_errors %&#125; &#123;% for error in form.non_field_errors %&#125; &lt;div class="well well-small text-error" style="border: none"&gt;&#123;&#123; error &#125;&#125;&lt;/div&gt; &#123;% endfor %&#125; &#123;% endif %&#125; &lt;div class="form-actions-no-box form-box"&gt; &lt;input type="submit" name="submit" value="登录" class="btn btn-primary form-control" id="submit-id-submit"&gt; &lt;/div&gt; &lt;/form&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pip使用小技巧]]></title>
    <url>%2F2017%2F05%2F25%2Fpip%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[pip命令是Python语言下安装第三方库的命令，一些基本的使用我这里就不多说了。 有时候我们可能会遇到这样的情况，我接手了一个现有的项目，因为正常情况我们都是使用virturalenv虚拟环境的，所以我们更换电脑后就需要重新安装项目的依赖库，这时候我们就有这样的快捷方法，在命令行工具中使用： 1$ pip freeze &gt; ~/Desktop/requirements.txt 我们就可以在桌面生成一个项目的依赖库目录文件，就像下图这样： 将这个文件放入Git仓库并且提交，这样其他协作开发人员只需要使用以下命令就能快速安装所有依赖库： 1$ pip install -r ~/Desktop/requirements.txt]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Develop Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客写作利器MWeb]]></title>
    <url>%2F2017%2F05%2F24%2FHexo%E5%8D%9A%E5%AE%A2%E5%86%99%E4%BD%9C%E5%88%A9%E5%99%A8MWeb%2F</url>
    <content type="text"><![CDATA[推荐MWeb是因为这个用Hexo驱动的博客，我都是用它进行写文章的，它确实是一个很好用的Markdown编辑器。 如果光是这样，那不足以让我向大家强烈推荐，其实主要原因是里面的图床功能很好用，它能直接绑定到七牛云服务。 因为Github Page提供的空间大小有限，所以你不可能所有图片资源都去放到你的博客仓库去，所以不可避免地你就要去上传图片，然后转成链接。 打开偏好设置选中发布服务，可以直接快速发布到其他博客平台，这些功能我没有使用，因为我都是自己的博客。重点就是下面的图床服务，在七牛云注册一个账号，是有免费10G的空间的，这完全足够你使用了… 注册完七牛云之后你就可以去填上相关的配置参数就可以使用图床功能了，你使用本地图片，它会自动为你上传到七牛云并且转成可供访问的外链，是不是很简单？！！ 更多详细的功能，你可以去看MWeb的官方文档。]]></content>
      <categories>
        <category>Softwares</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>Develop Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git图形化软件推荐]]></title>
    <url>%2F2017%2F05%2F24%2FGit%E5%9B%BE%E5%BD%A2%E5%8C%96%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90%2F</url>
    <content type="text"><![CDATA[我想所有码农都知道代码版本管理的重要性！这里我就不详细讲原因了…如果你是一个在命令行使用git命令飞起的攻城狮，那么请无视这篇文章。 为什么我会推荐图形化软件呢？因为很多开发者可能会畏惧所谓的命令行工具，而图形化软件更加直观清晰，可以直接看到每次的commit信息，每次history对应的代码修改，不同的branch信息等等。 Tower我个人开发主要使用的是MacOS系统，那么我首推的是Tower，因为使用的比较熟悉了… 界面很清爽，左侧展示了你所有的项目，右侧展示了项目详细的信息。 这是进入项目的主界面，所有的commit信息，history信息，branch信息都一览无余，所以相信我，等你使用后，你一定会喜欢上它！具体使用教程我就不多说了，毕竟git的操作无非就是那些东西，自己摸索一下就可以了。 GitKrakenGitKraken是我后来发现的一个git图形化软件，推荐它的原因是它支持Windows，MacOS，Linux！！！没错，我再Windows系统上就是用的它，因为Windows下官方的Git工具实在太难用了…另外官网有详细的使用教程。 和tower比起来，它的界面还是很炫酷的，而且独特的🐙logo还是很有特色的，让人印象很深刻。]]></content>
      <categories>
        <category>Softwares</category>
      </categories>
      <tags>
        <tag>Develop Tools</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django框架ImageField的使用]]></title>
    <url>%2F2017%2F05%2F24%2FDjango%E6%A1%86%E6%9E%B6ImageField%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[我们在日常生活中的网站上可以看到各种各样的图片，那么如果使用Django框架搭建后台服务，如何去实现图片的上传，加载呢？ 首先写一个简单的Model类： 123456class CourseOrg(models.Model): name = models.CharField(max_length=50, verbose_name=u'机构名称') image = models.ImageField(upload_to='org/%Y/%m', verbose_name=u'机构logo') class Meta: verbose_name = u'课程机构' 这里upload_to参数指定了一个相对路径，那么Django如何知道图片存放的根目录呢？ 没错，我们需要在settings.py文件中添加以下设置： 12MEDIA_URL = '/media/'MEDIA_ROOT = os.path.join(BASE_URL, 'media') 然后我们在工程创建名称为media的文件夹，完成以上步骤后就可以通过Django admin后台进行上传图片了。 那么我们在html文件中怎么将一个ImageField转换成url地址呢？我们看接下来html中的代码： 1&lt;img width="200" height="120" class="scrollLoading" data-url="&#123;&#123; MEDIA_URL &#125;&#125;&#123;&#123; course_org.image &#125;&#125;" src="&#123;% static "images/pixel.gif" %&#125;"/&gt; 这里我们需要注意的是，默认情况是无法取到MEDIA_URL变量的，我们需要在settings.py文件中找到TEMPLATES设置，并在OPTIONS配置的context_processors中增加元素：django.core.context_processors.media 完成以上步骤，我们还无法在网页上加载出图片，因为Django还不清楚怎么处理media目录下的url，所以最后我们要在urls.py文件中加上配置： 123456789from django.views.static import servefrom ProjectName.settings import MEDIA_ROOTurlpatterns = [ ... # 配置上传文件的访问处理函数 url(r'^media/(?P&lt;path&gt;.*)$', serve, &#123;"document_root": MEDIA_ROOT&#125;)] OK，我们已经完成所有操作，这时你已经可以加载出图片了！]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[switch/case的使用进阶]]></title>
    <url>%2F2017%2F05%2F16%2Fswitch%E7%9A%84%E4%BD%BF%E7%94%A8%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[基本使用switch/case是我们开发中经常用来做条件判断的语法，下面是我们常用的一种形式： 12345678910let name = "swift"switch name &#123;case "objc": print("Old iOS develop language!")case "swift": print("New iOS develop language!")default: print("Unknown language!")&#125; 当然，我们也会遇到相对复杂一些的情况，比如我们条件判断的值有多个，这个时候我们就会用到元组： 12345678910let authentication = (name: "twostraws", password: "fr0st1es")switch authentication &#123;case ("bilbo", "bagg1n5"): print("Hello, Bilbo Baggins!")case ("twostraws", "fr0st1es"): print("Hello, Paul Hudson!")default: print("Who are you?")&#125; 部分匹配有时候使用元组做条件判断的时候，我们可能并不关注元组中某些值，所以我们会忽略它们，是的，你猜的不错，就是使用下划线_： 12345678910let authentication = (name: "twostraws", password: "fr0st1es", ipAddress: "127.0.0.1")switch authentication &#123;case ("bilbo", "bagg1n5", _): print("Hello, Bilbo Baggins!")case ("twostraws", "fr0st1es", _): print("Hello, Paul Hudson!")default: print("Who are you?")&#125; 注意：Swift的switch匹配是从上到下，也就意味着如果某个值能匹配两种case，它只会成功进入第一种case逻辑 如果你只想匹配元组中一个值，但是你又想知道其他的值是什么，很简单，你只要使用let关键词定义一个常量来获取，就像下面获取password： 12345678switch authentication &#123;case ("bilbo", "bagg1n5", _): print("Hello, Bilbo Baggins!")case ("twostraws", let password, _): print("Hello, Paul Hudson: your password was \(password)!")default: print("Who are you?")&#125; 计算元组匹配上面的示例中元组中的值都是固定的，但是元组也可以用动态代码来创建，举个简单的例子： 1234567891011121314func fizzbuzz(number: Int) -&gt; String &#123; switch (number % 3 == 0, number % 5 == 0) &#123; case (true, false): return "Fizz" case (false, true): return "Buzz" case (true, true): return "FizzBuzz" case (false, false): return String(number) &#125;&#125;print(fizzbuzz(number: 15)) 这个时候，你给任意一个number，都可以进行正确的条件匹配。 循环123456789let twostraws = (name: "twostraws", password: "fr0st1es")let bilbo = (name: "bilbo", password: "bagg1n5")let taylor = (name: "taylor", password: "fr0st1es")let users = [twostraws, bilbo, taylor]for user in users &#123; print(user.name)&#125; 可能平时你看到了太多这样的for循环，是的，是个开发都知道，那接下来这种使用方法你可能不熟悉： 123for case ("twostraws", "fr0st1es") in users &#123; print("User twostraws has the password fr0st1es")&#125; 是不是很神奇，当然，你也可以用let去动态获取一个值，比如我知道password，我想知道对应的name： 123for case let (name, "fr0st1es") in users &#123; print("User \(name) has the password \"fr0st1es\"")&#125; 可选值匹配Swift有两种方法来匹配可选值，第一种是使用.some和.none来匹配有一个值和没有值： 1234567891011let name: String? = "twostraws"let password: String? = "fr0st1es"switch (name, password) &#123;case let (.some(name), .some(password)): print("Hello, \(name)")case let (.some(name), .none): print("Please enter a password.")default: print("Who are you?")&#125; 第二种方法更加简单： 12345678switch (name, password) &#123;case let (name?, password?): print("Hello, \(name)")case let (username?, nil): print("Please enter a password.")default: print("Who are you?")&#125; 再用数组举个简单的例子，你应该就可以完全理解了： 123456789let data: [Any?] = ["Bill", nil, 69, "Ted"]for case let .some(datum) in data &#123; print(datum)&#125;for case let datum? in data &#123; print(datum)&#125; 范围匹配是不是感觉快起飞了，一个switch/case竟然有这么多学问，其实我自己也被吓到了，范围匹配你可能经常使用这样的代码： 12345678910let age = 36switch age &#123;case 0 ..&lt; 18: print("You have the energy and time, but not the money")case 18 ..&lt; 70: print("You have the energy and money, but not the time")default: print("You have the time and money, but not the energy")&#125; 当然，条件判断也是可以使用的，我这里简单延伸一下，你可能会像这样去写： 1234567if case 0 ..&lt; 18 = age &#123; print("You have the energy and time, but not the money")&#125; else if case 18 ..&lt; 70 = age &#123; print("You have the energy and money, but not the time")&#125; else &#123; print("You have the time and money, but not the energy")&#125; 其实这没什么问题，但是有些人可能会有强迫症，我介绍两种更加直观易读的方式： 使用~=操作符 1234567if 0 ..&lt; 18 ~= age &#123; print("You have the energy and time, but not the money")&#125; else if 18 ..&lt; 70 ~= age &#123; print("You have the energy and money, but not the time")&#125; else &#123; print("You have the time and money, but not the energy")&#125; 使用Range的contains()方法 1234567if (0 ..&lt; 18).contains(age) &#123; print("You have the energy and time, but not the money")&#125; else if (18 ..&lt; 70).contains(age) &#123; print("You have the energy and money, but not the time")&#125; else &#123; print("You have the time and money, but not the energy")&#125; 怎么样，是不是可读性更强了！ 你可以将范围匹配和元组匹配合并起来，就像这样： 12345678910let user = (name: "twostraws", password: "fr0st1es", age: 36)switch user &#123;case let (name, _, 0 ..&lt; 18): print("\(name) has the energy and time, but no money")case let (name, _, 18 ..&lt; 70): print("\(name) has the money and energy, but no time")case let (name, _, _): print("\(name) has the time and money, but no energy")&#125; 枚举和关联值匹配可能还有些人不太理解枚举和关联值，枚举在Swift中变得非常强大，后面我会再单独写一个枚举相关的进阶。这里我们先看一个最基本的枚举匹配： 12345678910111213141516enum WeatherType &#123; case cloudy case sunny case windy&#125;let today = WeatherType.cloudyswitch today &#123;case .cloudy: print("It's cloudy")case .windy: print("It's windy")default: print("It's sunny")&#125; 有时候在条件判断你也会用到枚举，就像这样： 123if today == .cloudy &#123; print("It's cloudy")&#125; 这些都很简单，但是一旦你加入了关联值，就会变得复杂起来，因为你可以使用它们，忽略它们，或者基于它们进行过滤。 修改一下前面的代码，加上一个关联值，然后获取对应的值： 12345678910111213141516enum WeatherType &#123; case cloudy(coverage: Int) case sunny case windy&#125;let today = WeatherType.cloudy(coverage: 100)switch today &#123;case .cloudy(let coverage): print("It's cloudy with \(coverage)% coverage")case .windy: print("It's windy")default: print("It's sunny")&#125; 还是挺容易的，那么如何加上过滤条件呢？这时候我们就要使用where关键词创建一个你想查询的条件语句： 123456789101112131415161718enum WeatherType &#123; case cloudy(coverage: Int) case sunny case windy&#125;let today = WeatherType.cloudy(coverage: 100)switch today &#123;case .cloudy(let coverage) where coverage &lt; 100: print("It's cloudy with \(coverage)% coverage")case .cloudy(let coverage) where coverage == 100: print("You must live in the UK")case .windy: print("It's windy")default: print("It's sunny")&#125; 再放一个大招，将范围匹配和可选值匹配组合起来，你能猜到是什么样的吗？好吧，不管你会不会，我都要举个例子： 1234567891011121314151617181920212223242526272829303132enum WeatherType &#123; case cloudy(coverage: Int) case sunny case windy&#125;let today = WeatherType.cloudy(coverage: 100)switch today &#123;case .cloudy(let coverage) where coverage == 0: print("You must live in Death Valley")case .cloudy(let coverage) where (1...50).contains(coverage): print("It's a bit cloudy, with \(coverage)% coverage")case .cloudy(let coverage) where (51...99).contains(coverage): print("It's very cloudy, with \(coverage)% coverage")case .cloudy(let coverage) where coverage == 100: print("You must live in the UK")case .windy: print("It's windy")default: print("It's sunny")&#125;``` &gt; 注意：像下面这样使用**where**在循环中匹配关联值是不行的，如果没有关联值可以使用**where**```swiftlet forecast: [WeatherType] = [.cloudy(coverage: 40), .sunny, .windy, .cloudy(coverage: 100), .sunny]for day in forecast where day == .cloudy &#123; print(day)&#125; 正确的方式应该是这样的： 12345let forecast: [WeatherType] = [.cloudy(coverage: 40), .sunny, .windy, .cloudy(coverage: 100), .sunny]for case let .cloudy(coverage) in forecast &#123; print("It's cloudy with \(coverage)% coverage")&#125; 类型匹配说到类型匹配，就应该想到is关键词： 1234567891011121314let view: AnyObject = UIButton()switch view &#123;case is UIButton: print("Found a button")case is UILabel: print("Found a label")case is UISwitch: print("Found a switch")case is UIView: print("Found a view")default: print("Found something else")&#125; 上面的代码你会发现一个问题，UIButton是继承UIView的，上面的结果会进入第一个case语句，那么我们调换一下顺序： 1234567891011121314let view: AnyObject = UIButton()switch view &#123;case is UIView: print("Found a view")case is UIButton: print("Found a button")case is UILabel: print("Found a label")case is UISwitch: print("Found a switch")default: print("Found something else")&#125; 这样代码会进入第一个case语句，我想你已经知道我为什么要说明这个了，没错，前面我已经讲过了匹配顺序的问题。 最后我再举一个实用的例子： 123for label in view.subviews where label is UILabel &#123; print("Found a label with frame \(label.frame)")&#125; 这里frame属性其实是UIView的，如果我们要使用UILabel的text属性，我们要这样： 123for case let label as UILabel in view.subviews &#123; print("Found a label with text \(label.text)")&#125; 怎么样，是不是感觉已经超神了？？？]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GameplayKit框架中的神器]]></title>
    <url>%2F2017%2F05%2F16%2FGameplayKit%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E7%A5%9E%E5%99%A8%2F</url>
    <content type="text"><![CDATA[GameplayKit是苹果为开发游戏提供的自带系统框架，可能作为App开发者平时几乎不使用该框架，但是使用过该框架的开发者们都会惊奇地发现里面有许多方便好用的方法： 1234567import GameplayKit//打乱数组顺序let countries = GKRandomSource.sharedRandom().arrayByShufflingObjects(in: countries) as! [String]//生成随机数let correctAnswer = GKRandomSource.sharedRandom().nextInt(upperBound: 3)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Foundation</tag>
      </tags>
  </entry>
</search>
